// Trigger fires off your workflow and returns the AmeliaResponse.
func (c *AmeliaClient) Trigger(ctx context.Context, reqBody TriggerRequest) (*AmeliaResponse, error) {
	// 1) Ensure ReferenceID
	if reqBody.ReferenceID == "" {
		return nil, errors.New("amelia: ReferenceID required")
	}

	// 2) Get a valid bearer token
	token, err := c.getToken(ctx)
	if err != nil {
		return nil, err
	}

	// 3) Marshal the JSON payload
	bodyBytes, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("amelia: payload marshal failed: %w", err)
	}

	// 4) Build the HTTP request
	httpReq, err := http.NewRequestWithContext(ctx,
		http.MethodPost,
		c.cfg.EventsURL,
		bytes.NewReader(bodyBytes),
	)
	if err != nil {
		return nil, fmt.Errorf("creating trigger request: %w", err)
	}

	// 5) Mirror Postmanâ€™s headers exactly
	httpReq.Header.Set("Authorization", "Bearer "+token)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("Accept", "application/json")
	httpReq.Header.Set("X-Amelia-DomainCode", "linuxoseng")
	httpReq.Header.Set("X-Amelia-ClientKey", "6163ad0f20b54ac18e8d18a8280243961722950538D7Kum4")

	// 6) Send via the plain DefaultClient (no extra OAuth magic)
	resp, err := http.DefaultClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("amelia: trigger request failed: %w", err)
	}
	defer resp.Body.Close()

	// 7) Check status
	if resp.StatusCode != http.StatusAccepted && resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("amelia: trigger returned %d %s", resp.StatusCode, string(body))
	}

	// 8) Decode the JSON response
	var ar AmeliaResponse
	if err := json.NewDecoder(resp.Body).Decode(&ar); err != nil {
		return nil, fmt.Errorf("amelia: response parse failed: %w", err)
	}
	return &ar, nil
}
